#include <iostream>
#include <cstring>
#include <iomanip>

using namespace std;

// Initial hash values (first 32 bits of the square roots of the first 8 primes)
unsigned int H[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
};

// Constants (first 32 bits of the cube roots of the first 64 primes)
unsigned int K[64] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    // ... More values ...
    0xbef9a3f7, 0xc67178f2
};

// Right rotate function
unsigned int rotr(unsigned int x, unsigned int n) {
    return (x >> n) | (x << (32 - n));
}

// SHA-256 Compression functions
unsigned int Ch(unsigned int x, unsigned int y, unsigned int z) {
    return (x & y) ^ (~x & z);
}

unsigned int Maj(unsigned int x, unsigned int y, unsigned int z) {
    return (x & y) ^ (x & z) ^ (y & z);
}

unsigned int Sigma0(unsigned int x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
}

unsigned int Sigma1(unsigned int x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
}

unsigned int sigma0(unsigned int x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ (x >> 3);
}

unsigned int sigma1(unsigned int x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ (x >> 10);
}

// SHA-256 Hash Computation for a single 512-bit block
void processBlock(unsigned int *M) {
    unsigned int W[64];

    // Prepare the message schedule W
    for (int i = 0; i < 16; i++) W[i] = M[i];
    for (int i = 16; i < 64; i++)
        W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];

    // Initialize working variables to current hash value
    unsigned int a = H[0], b = H[1], c = H[2], d = H[3];
    unsigned int e = H[4], f = H[5], g = H[6], h = H[7];

    // Main compression loop
    for (int i = 0; i < 64; i++) {
        unsigned int temp1 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];
        unsigned int temp2 = Sigma0(a) + Maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + temp1;
        d = c;
        c = b;
        b = a;
        a = temp1 + temp2;
    }

    // Update the hash values
    H[0] += a;
    H[1] += b;
    H[2] += c;
    H[3] += d;
    H[4] += e;
    H[5] += f;
    H[6] += g;
    H[7] += h;
}

// Function to display final hash
void printHash() {
    for (int i = 0; i < 8; i++)
        cout << hex << setw(8) << setfill('0') << H[i];
    cout << endl;
}

int main() {
    // Example message (padded manually for simplicity)
    unsigned int M[16] = {0x61626380, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24};

    // Process the message block
    processBlock(M);

    // Print the resulting SHA-256 hash
    cout << "SHA-256 Hash: ";
    printHash();

    return 0;
}
